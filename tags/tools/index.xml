<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tools on PHP Scaling</title><link>https://phpscaling.com/tags/tools/</link><description>Recent content in tools on PHP Scaling</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2008–2023, Alister Bulman; all rights reserved</copyright><lastBuildDate>Thu, 06 Dec 2018 13:31:44 +0000</lastBuildDate><atom:link href="https://phpscaling.com/tags/tools/index.xml" rel="self" type="application/rss+xml"/><item><title>Investigating RedisGraph</title><link>https://phpscaling.com/post/investigating-redisgraph/</link><pubDate>Thu, 06 Dec 2018 13:31:44 +0000</pubDate><guid>https://phpscaling.com/post/investigating-redisgraph/</guid><description>
Thus far, I've not done anything serious with much more with database like Mysql, some Postgres and on the NoSql side MongoDB (with a frisson of some use of Redis for some barely-more-than basic things), but I saw some mention of using RedisGraph PHP Client back in late October, as part of my regular scan of the packagist feed for new PHP/Composer packages.
The 'kjdev/redis-graph' package is the first example of an interface library to RedisGraph - an extension module to Redis that became possible with Redis 4.</description></item><item><title>Speeding up your tests, and also your code coverage!</title><link>https://phpscaling.com/post/speeding-up-your-tests/</link><pubDate>Wed, 19 Sep 2018 21:42:44 +0000</pubDate><guid>https://phpscaling.com/post/speeding-up-your-tests/</guid><description>
Slow running tests are a bug - they stop you from doing as much as you can with your code, &amp;amp; its quality. Spend a little time working on making your tests better, clearer, and faster - and you'll reap rewards from your work.
I've had a couple of useful improvements in the time spent running my PHPunit tests recently.
First was avoiding setting up the database in each test, and using the Alice library (via AliceBundle) to pre-create at least the majority of the data my tests will need.</description></item><item><title>Code Tombstones</title><link>https://phpscaling.com/post/code-tombstones/</link><pubDate>Mon, 28 Aug 2017 18:43:06 +0000</pubDate><guid>https://phpscaling.com/post/code-tombstones/</guid><description>
Version 0.9 of scheb/tombstone autoloads a file with a tombstone() function. See the bottom of the post for a fix to override that in your own code.
In a large project - particularly one in a dynamic language like PHP, as a project gets bigger maintaining full control of the code can be difficult. New features are written, old ones are changed or deprecated. Sometimes code is left behind, unneeded in later versions, but still in the code-base.</description></item><item><title>Replacing @expectedException with $this->expectException()</title><link>https://phpscaling.com/post/replacing-expectedexception-with-this-expectexception/</link><pubDate>Tue, 08 Aug 2017 18:59:44 +0000</pubDate><guid>https://phpscaling.com/post/replacing-expectedexception-with-this-expectexception/</guid><description>
One of the advantages of a side-project is that you can be a little extra passionate about getting things just right. If you want to increase code coverage because you think that it's good, you can - after all, it's just some time now doing things that you like.
So, earlier in the year, when I saw Sebastian Bergmann's article on 'Questioning PHPUnit Best Practices', I added it to a little (well, it currently stands at a count of 20 items.</description></item><item><title>Upgrading PHPunit - fixing PHPUnit_Util_DeprecatedFeature_Logger</title><link>https://phpscaling.com/post/upgrading-phpunit-fixing-phpunit_util_deprecatedfeature_logger/</link><pubDate>Thu, 11 Jun 2015 13:04:07 +0000</pubDate><guid>https://phpscaling.com/post/upgrading-phpunit-fixing-phpunit_util_deprecatedfeature_logger/</guid><description>
Having just watched Sebastian Bergmann's &amp;quot;The State of PHPUnit&amp;quot; presentation from Fosdem 2015, I was inspired to install and test a project of mine with the latest stable PHPUnit - v4.7. It was easily installed on the command line.
composer global require &amp;quot;phpunit/phpunit&amp;quot;
I installed it as a new, global, tool because in my project I am using the &amp;quot;ibuildings/qa-tools&amp;quot; repository to install and help run a number of QA tools - and the stable 1.</description></item><item><title>Recently....</title><link>https://phpscaling.com/post/recently/</link><pubDate>Tue, 03 Apr 2012 11:03:33 +0000</pubDate><guid>https://phpscaling.com/post/recently/</guid><description>
It's been one of those quiet spots around here for a while, so here's the catch-up on what has been happening while I was not posting.
I've recently finished a short contract working with an agency, Transform (part of the Engine group) working with a couple of government departments. The Office Of The Public Guardian receives, checks and stores Lasting Powers of Attorney - a legal document that you write while still mentally compentant to say what you would like to happen should the worst occur, and by whom you want to do it.</description></item><item><title>Deployment with Capistrano - the Gotchas</title><link>https://phpscaling.com/post/deployment-with-capistrano-the-gotchas/</link><pubDate>Thu, 24 Nov 2011 12:16:59 +0000</pubDate><guid>https://phpscaling.com/post/deployment-with-capistrano-the-gotchas/</guid><description>
Capistrano, makes deployment of code easy. If you need to do a number of additional steps as well, then the fact that they can be scripted and run automatically is a huge win.
If you've only got a single machine (or maybe two), then you could certainly write your own quite simple, and entirely workable system - I described something just like this in a previous post: &amp;quot;SVN checkouts vs exports for live versions&amp;quot;.</description></item><item><title>Doing the work elsewhere - Adding a job to the queue</title><link>https://phpscaling.com/post/doing-the-work-elsewhere-adding-a-job-to-the-queue/</link><pubDate>Tue, 06 Oct 2009 22:30:26 +0000</pubDate><guid>https://phpscaling.com/post/doing-the-work-elsewhere-adding-a-job-to-the-queue/</guid><description>
I've previously shown you why you may want to put some tasks through a queuing system, what sort of jobs you could define, plus how to keep a worker process running for as long as you would like (but still be mindful of problems that happen).
In this post, I'll show you how to put the messages into the queue, and we'll also make a start on reading them back out.</description></item><item><title>Always have up to date documentation, part #2</title><link>https://phpscaling.com/post/always-have-up-to-date-documentation-part-2/</link><pubDate>Mon, 24 Mar 2008 15:38:28 +0000</pubDate><guid>https://phpscaling.com/post/always-have-up-to-date-documentation-part-2/</guid><description>
see my previous post on the topic, #1.
My last post ended up more as a how-to than what-to. This time, I'll say why you should have local copies of the documentation for most of the tools you use. I'll also tell you the sort of things I always have handy as well.
Getting a local copy of php.net - and getting installed as an apache vhost and updated (probably weekly) is some effort, but well worth it.</description></item><item><title>Always have up to date documentation, part #1</title><link>https://phpscaling.com/post/always-have-up-to-date-documentation-part-1/</link><pubDate>Sun, 16 Mar 2008 23:41:00 +0000</pubDate><guid>https://phpscaling.com/post/always-have-up-to-date-documentation-part-1/</guid><description>
As I mentioned in my second post, ZCE prep – and dumb tests - about open book tests (like Brainbench), having a copy of all the relevant documentation can be incredibly useful, if only from a speed issue. Knowing you can just open a new tab and type a few words to get the information on a function, or concept from the manual takes away so many problems.
I mentioned there that I have a local copy of the main PHP manual – and I wanted to tell you how I keep it, and a couple of other manuals up to date, as well as other documentation.</description></item><item><title>svn checkouts vs exports for live versions</title><link>https://phpscaling.com/post/svn-checkouts-vs-exports-for-live-versions/</link><pubDate>Sun, 09 Mar 2008 19:45:30 +0000</pubDate><guid>https://phpscaling.com/post/svn-checkouts-vs-exports-for-live-versions/</guid><description>
I've read http://www.svn-checkout.co.uk/2008/01/19/how-to-release-new-versions-of-websites/ via http://www.lornajane.net/posts/2008/SVN-Deployment-and-a-New-Site and while I consider revision control an essential tool (a few years ago, my job was the only one in the previous five years where I didn't have to install my own RCS), I somewhat disagree on the idea they suggest.
That first link, 'how to release new versions of websites', suggests checking out a version of the site as a working copy, (it's certainly something I've done before now), but then it goes on to use the 'svn switch' capability to move between versions (of course, they are also doing in in TortoiseSvn, and there for the live web-server is likely to be running Windows, no way I'd run a server on Windows - not even for testing).</description></item></channel></rss>